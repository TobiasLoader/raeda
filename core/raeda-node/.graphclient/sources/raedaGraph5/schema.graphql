schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Bid {
  id: String!
  EOA: Bytes!
  amount: BigInt!
  accepted: Boolean
  bidder: Profile!
  post: Post!
}

input Bid_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  EOA: Bytes
  EOA_not: Bytes
  EOA_gt: Bytes
  EOA_lt: Bytes
  EOA_gte: Bytes
  EOA_lte: Bytes
  EOA_in: [Bytes!]
  EOA_not_in: [Bytes!]
  EOA_contains: Bytes
  EOA_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  accepted: Boolean
  accepted_not: Boolean
  accepted_in: [Boolean!]
  accepted_not_in: [Boolean!]
  bidder: String
  bidder_not: String
  bidder_gt: String
  bidder_lt: String
  bidder_gte: String
  bidder_lte: String
  bidder_in: [String!]
  bidder_not_in: [String!]
  bidder_contains: String
  bidder_contains_nocase: String
  bidder_not_contains: String
  bidder_not_contains_nocase: String
  bidder_starts_with: String
  bidder_starts_with_nocase: String
  bidder_not_starts_with: String
  bidder_not_starts_with_nocase: String
  bidder_ends_with: String
  bidder_ends_with_nocase: String
  bidder_not_ends_with: String
  bidder_not_ends_with_nocase: String
  bidder_: Profile_filter
  post: String
  post_not: String
  post_gt: String
  post_lt: String
  post_gte: String
  post_lte: String
  post_in: [String!]
  post_not_in: [String!]
  post_contains: String
  post_contains_nocase: String
  post_not_contains: String
  post_not_contains_nocase: String
  post_starts_with: String
  post_starts_with_nocase: String
  post_not_starts_with: String
  post_not_starts_with_nocase: String
  post_ends_with: String
  post_ends_with_nocase: String
  post_not_ends_with: String
  post_not_ends_with_nocase: String
  post_: Post_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Bid_filter]
  or: [Bid_filter]
}

enum Bid_orderBy {
  id
  EOA
  amount
  accepted
  bidder
  bidder__id
  bidder__profileName
  bidder__waterType
  bidder__description
  post
  post__id
  post__postName
  post__description
  post__EOA
  post__price
  post__iXx
  post__iXy
  post__fXx
  post__fXy
  post__iT
  post__fT
  post__exp
  post__live
  post__pendingValue
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

type Bucket {
  id: Bytes!
  category: String!
  value: String!
  post: Post
}

input Bucket_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  category: String
  category_not: String
  category_gt: String
  category_lt: String
  category_gte: String
  category_lte: String
  category_in: [String!]
  category_not_in: [String!]
  category_contains: String
  category_contains_nocase: String
  category_not_contains: String
  category_not_contains_nocase: String
  category_starts_with: String
  category_starts_with_nocase: String
  category_not_starts_with: String
  category_not_starts_with_nocase: String
  category_ends_with: String
  category_ends_with_nocase: String
  category_not_ends_with: String
  category_not_ends_with_nocase: String
  value: String
  value_not: String
  value_gt: String
  value_lt: String
  value_gte: String
  value_lte: String
  value_in: [String!]
  value_not_in: [String!]
  value_contains: String
  value_contains_nocase: String
  value_not_contains: String
  value_not_contains_nocase: String
  value_starts_with: String
  value_starts_with_nocase: String
  value_not_starts_with: String
  value_not_starts_with_nocase: String
  value_ends_with: String
  value_ends_with_nocase: String
  value_not_ends_with: String
  value_not_ends_with_nocase: String
  post: String
  post_not: String
  post_gt: String
  post_lt: String
  post_gte: String
  post_lte: String
  post_in: [String!]
  post_not_in: [String!]
  post_contains: String
  post_contains_nocase: String
  post_not_contains: String
  post_not_contains_nocase: String
  post_starts_with: String
  post_starts_with_nocase: String
  post_not_starts_with: String
  post_not_starts_with_nocase: String
  post_ends_with: String
  post_ends_with_nocase: String
  post_not_ends_with: String
  post_not_ends_with_nocase: String
  post_: Post_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Bucket_filter]
  or: [Bucket_filter]
}

enum Bucket_orderBy {
  id
  category
  value
  post
  post__id
  post__postName
  post__description
  post__EOA
  post__price
  post__iXx
  post__iXy
  post__fXx
  post__fXy
  post__iT
  post__fT
  post__exp
  post__live
  post__pendingValue
}

scalar Bytes

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Post {
  id: Bytes!
  postName: String!
  description: String!
  EOA: Bytes!
  price: BigInt!
  iXx: BigInt!
  iXy: BigInt!
  fXx: BigInt!
  fXy: BigInt!
  iT: Int
  fT: Int
  exp: BigInt!
  live: Boolean!
  bucket(skip: Int = 0, first: Int = 100, orderBy: Bucket_orderBy, orderDirection: OrderDirection, where: Bucket_filter): [Bucket!]
  pendingValue: dealStates
  poster: Profile!
  bids(skip: Int = 0, first: Int = 100, orderBy: Bid_orderBy, orderDirection: OrderDirection, where: Bid_filter): [Bid!]
}

input Post_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  postName: String
  postName_not: String
  postName_gt: String
  postName_lt: String
  postName_gte: String
  postName_lte: String
  postName_in: [String!]
  postName_not_in: [String!]
  postName_contains: String
  postName_contains_nocase: String
  postName_not_contains: String
  postName_not_contains_nocase: String
  postName_starts_with: String
  postName_starts_with_nocase: String
  postName_not_starts_with: String
  postName_not_starts_with_nocase: String
  postName_ends_with: String
  postName_ends_with_nocase: String
  postName_not_ends_with: String
  postName_not_ends_with_nocase: String
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  EOA: Bytes
  EOA_not: Bytes
  EOA_gt: Bytes
  EOA_lt: Bytes
  EOA_gte: Bytes
  EOA_lte: Bytes
  EOA_in: [Bytes!]
  EOA_not_in: [Bytes!]
  EOA_contains: Bytes
  EOA_not_contains: Bytes
  price: BigInt
  price_not: BigInt
  price_gt: BigInt
  price_lt: BigInt
  price_gte: BigInt
  price_lte: BigInt
  price_in: [BigInt!]
  price_not_in: [BigInt!]
  iXx: BigInt
  iXx_not: BigInt
  iXx_gt: BigInt
  iXx_lt: BigInt
  iXx_gte: BigInt
  iXx_lte: BigInt
  iXx_in: [BigInt!]
  iXx_not_in: [BigInt!]
  iXy: BigInt
  iXy_not: BigInt
  iXy_gt: BigInt
  iXy_lt: BigInt
  iXy_gte: BigInt
  iXy_lte: BigInt
  iXy_in: [BigInt!]
  iXy_not_in: [BigInt!]
  fXx: BigInt
  fXx_not: BigInt
  fXx_gt: BigInt
  fXx_lt: BigInt
  fXx_gte: BigInt
  fXx_lte: BigInt
  fXx_in: [BigInt!]
  fXx_not_in: [BigInt!]
  fXy: BigInt
  fXy_not: BigInt
  fXy_gt: BigInt
  fXy_lt: BigInt
  fXy_gte: BigInt
  fXy_lte: BigInt
  fXy_in: [BigInt!]
  fXy_not_in: [BigInt!]
  iT: Int
  iT_not: Int
  iT_gt: Int
  iT_lt: Int
  iT_gte: Int
  iT_lte: Int
  iT_in: [Int!]
  iT_not_in: [Int!]
  fT: Int
  fT_not: Int
  fT_gt: Int
  fT_lt: Int
  fT_gte: Int
  fT_lte: Int
  fT_in: [Int!]
  fT_not_in: [Int!]
  exp: BigInt
  exp_not: BigInt
  exp_gt: BigInt
  exp_lt: BigInt
  exp_gte: BigInt
  exp_lte: BigInt
  exp_in: [BigInt!]
  exp_not_in: [BigInt!]
  live: Boolean
  live_not: Boolean
  live_in: [Boolean!]
  live_not_in: [Boolean!]
  bucket_: Bucket_filter
  pendingValue: dealStates
  pendingValue_not: dealStates
  pendingValue_in: [dealStates!]
  pendingValue_not_in: [dealStates!]
  poster: String
  poster_not: String
  poster_gt: String
  poster_lt: String
  poster_gte: String
  poster_lte: String
  poster_in: [String!]
  poster_not_in: [String!]
  poster_contains: String
  poster_contains_nocase: String
  poster_not_contains: String
  poster_not_contains_nocase: String
  poster_starts_with: String
  poster_starts_with_nocase: String
  poster_not_starts_with: String
  poster_not_starts_with_nocase: String
  poster_ends_with: String
  poster_ends_with_nocase: String
  poster_not_ends_with: String
  poster_not_ends_with_nocase: String
  poster_: Profile_filter
  bids_: Bid_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Post_filter]
  or: [Post_filter]
}

enum Post_orderBy {
  id
  postName
  description
  EOA
  price
  iXx
  iXy
  fXx
  fXy
  iT
  fT
  exp
  live
  bucket
  pendingValue
  poster
  poster__id
  poster__profileName
  poster__waterType
  poster__description
  bids
}

type Profile {
  id: Bytes!
  profileName: String!
  waterType: waterTypes!
  EOAs: [Bytes!]
  description: String!
  bids(skip: Int = 0, first: Int = 100, orderBy: Bid_orderBy, orderDirection: OrderDirection, where: Bid_filter): [Bid!]
  posts(skip: Int = 0, first: Int = 100, orderBy: Post_orderBy, orderDirection: OrderDirection, where: Post_filter): [Post!]
}

input Profile_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  profileName: String
  profileName_not: String
  profileName_gt: String
  profileName_lt: String
  profileName_gte: String
  profileName_lte: String
  profileName_in: [String!]
  profileName_not_in: [String!]
  profileName_contains: String
  profileName_contains_nocase: String
  profileName_not_contains: String
  profileName_not_contains_nocase: String
  profileName_starts_with: String
  profileName_starts_with_nocase: String
  profileName_not_starts_with: String
  profileName_not_starts_with_nocase: String
  profileName_ends_with: String
  profileName_ends_with_nocase: String
  profileName_not_ends_with: String
  profileName_not_ends_with_nocase: String
  waterType: waterTypes
  waterType_not: waterTypes
  waterType_in: [waterTypes!]
  waterType_not_in: [waterTypes!]
  EOAs: [Bytes!]
  EOAs_not: [Bytes!]
  EOAs_contains: [Bytes!]
  EOAs_contains_nocase: [Bytes!]
  EOAs_not_contains: [Bytes!]
  EOAs_not_contains_nocase: [Bytes!]
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  bids_: Bid_filter
  posts_: Post_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Profile_filter]
  or: [Profile_filter]
}

enum Profile_orderBy {
  id
  profileName
  waterType
  EOAs
  description
  bids
  posts
}

type Query {
  profile(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Profile
  profiles(
    skip: Int = 0
    first: Int = 100
    orderBy: Profile_orderBy
    orderDirection: OrderDirection
    where: Profile_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Profile!]!
  post(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Post
  posts(
    skip: Int = 0
    first: Int = 100
    orderBy: Post_orderBy
    orderDirection: OrderDirection
    where: Post_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Post!]!
  bucket(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bucket
  buckets(
    skip: Int = 0
    first: Int = 100
    orderBy: Bucket_orderBy
    orderDirection: OrderDirection
    where: Bucket_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Bucket!]!
  bid(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bid
  bids(
    skip: Int = 0
    first: Int = 100
    orderBy: Bid_orderBy
    orderDirection: OrderDirection
    where: Bid_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Bid!]!
  Search(
    text: String!
    first: Int = 100
    skip: Int = 0
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Post!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  profile(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Profile
  profiles(
    skip: Int = 0
    first: Int = 100
    orderBy: Profile_orderBy
    orderDirection: OrderDirection
    where: Profile_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Profile!]!
  post(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Post
  posts(
    skip: Int = 0
    first: Int = 100
    orderBy: Post_orderBy
    orderDirection: OrderDirection
    where: Post_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Post!]!
  bucket(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bucket
  buckets(
    skip: Int = 0
    first: Int = 100
    orderBy: Bucket_orderBy
    orderDirection: OrderDirection
    where: Bucket_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Bucket!]!
  bid(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bid
  bids(
    skip: Int = 0
    first: Int = 100
    orderBy: Bid_orderBy
    orderDirection: OrderDirection
    where: Bid_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Bid!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

enum dealStates {
  NOTCLOSED
  LAKECLOSED
  RIVERCLOSED
  BOTHCLOSED
}

enum waterTypes {
  LAKE
  RIVER
}